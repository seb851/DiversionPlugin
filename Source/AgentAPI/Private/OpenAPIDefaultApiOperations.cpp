// Copyright 2024 Diversion Company, Inc. All Rights Reserved.
/**
 * Agent API
 * API of Diversion sync agent
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIDefaultApiOperations.h"

#include "AgentAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace AgentAPI
{

FString OpenAPIDefaultApi::AddOrUpdateClonedWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::AddOrUpdateClonedWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIWorkspaceConfiguration);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIWorkspaceConfiguration) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIWorkspaceConfiguration) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::AddOrUpdateClonedWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::AddOrUpdateClonedWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CloneRepositoryRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/clone"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::CloneRepositoryRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICloneRepo);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPICloneRepo) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPICloneRepo) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CloneRepositoryResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 400:
		SetResponseString(TEXT("User error"));
		break;
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::CloneRepositoryResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::CoreAccessTokenRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/token/core"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::CoreAccessTokenRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::CoreAccessTokenResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 400:
		SetResponseString(TEXT("No authenticated user"));
		break;
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::CoreAccessTokenResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GenerateSupportBundleRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/support/bundle"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GenerateSupportBundleRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPISupportBundle);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPISupportBundle) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPISupportBundle) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::GenerateSupportBundleResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::GenerateSupportBundleResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetAllWorkspacesRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/workspaces"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetAllWorkspacesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetAllWorkspacesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::GetAllWorkspacesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetFileSyncStatusRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}/files/status"), PathParams);

	TArray<FString> QueryParams;
	if(Paths.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Paths.GetValue(), TEXT("Paths")));
	}
	InnerGeneratorOpenAPIPath += TCHAR('?');
	InnerGeneratorOpenAPIPath += FString::Join(QueryParams, TEXT("&"));

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetFileSyncStatusRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetFileSyncStatusResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 400:
		SetResponseString(TEXT("User error"));
		break;
	case 412:
		SetResponseString(TEXT("Failed to get file sync status due to initialization or internal error state"));
		break;
	}
}

bool OpenAPIDefaultApi::GetFileSyncStatusResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetSyncProgressRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}/sync/progress"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetSyncProgressRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetSyncProgressResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 412:
		SetResponseString(TEXT("Failed to get sync progress due to initialization or internal error state"));
		break;
	}
}

bool OpenAPIDefaultApi::GetSyncProgressResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::GetWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetWorkspaceByPathRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/workspace"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("abs_path=")) + ToUrlString(AbsPath));
	InnerGeneratorOpenAPIPath += TCHAR('?');
	InnerGeneratorOpenAPIPath += FString::Join(QueryParams, TEXT("&"));

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetWorkspaceByPathRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetWorkspaceByPathResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::GetWorkspaceByPathResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetWorkspaceSyncStatusRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}/sync"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetWorkspaceSyncStatusRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetWorkspaceSyncStatusResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::GetWorkspaceSyncStatusResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::GetWorkspacesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspaces"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::GetWorkspacesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::GetWorkspacesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::GetWorkspacesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::IsAliveRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/health"));
	TArray<FString> QueryParams;
	if(DumpTrace.IsSet())
	{
		QueryParams.Add(FString(TEXT("dump_trace=")) + ToUrlString(DumpTrace.GetValue()));
	}
	InnerGeneratorOpenAPIPath += TCHAR('?');
	InnerGeneratorOpenAPIPath += FString::Join(QueryParams, TEXT("&"));

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::IsAliveRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::IsAliveResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::IsAliveResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::ListDirRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/utils/list_dir"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::ListDirRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIListDirRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIListDirRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIListDirRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ListDirResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::ListDirResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIDefaultApi::NotifyOfAuthEventRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/notify/auth"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::NotifyOfAuthEventRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIAuthNotification);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIAuthNotification) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIAuthNotification) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::NotifyOfAuthEventResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::NotifyOfAuthEventResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::NotifyScanRequiredRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/workspace/{WorkspaceID}/scan"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::NotifyScanRequiredRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::NotifyScanRequiredResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Accepted"));
		break;
	case 404:
		SetResponseString(TEXT("Workspace with the input parameters not found"));
		break;
	case 503:
		SetResponseString(TEXT("Workspace has errors and cannot be scanned"));
		break;
	}
}

bool OpenAPIDefaultApi::NotifyScanRequiredResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::NotifySyncRequiredRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}/sync"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::NotifySyncRequiredRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::NotifySyncRequiredResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::NotifySyncRequiredResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::OpenLocalWorkspaceRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/utils/open_workspace"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::OpenLocalWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIOpenLocalWorkspaceRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIOpenLocalWorkspaceRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIOpenLocalWorkspaceRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::OpenLocalWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 404:
		SetResponseString(TEXT("cloned workspace with the input parameters not found"));
		break;
	}
}

bool OpenAPIDefaultApi::OpenLocalWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::OpenLocalWorkspaceFileRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/utils/open_workspace_file"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::OpenLocalWorkspaceFileRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIOpenWorkspaceFileParams);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIOpenWorkspaceFileParams) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIOpenWorkspaceFileParams) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::OpenLocalWorkspaceFileResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 404:
		SetResponseString(TEXT("file with the provided path was not found"));
		break;
	}
}

bool OpenAPIDefaultApi::OpenLocalWorkspaceFileResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::PauseWorkspaceSyncRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/workspace/{WorkspaceID}/sync/pause"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::PauseWorkspaceSyncRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::PauseWorkspaceSyncResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 404:
		SetResponseString(TEXT("Workspace with the input parameters not found"));
		break;
	case 409:
		SetResponseString(TEXT("Workspace is already paused"));
		break;
	}
}

bool OpenAPIDefaultApi::PauseWorkspaceSyncResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::RemoveClonedWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::RemoveClonedWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPIDefaultApi::RemoveClonedWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::RemoveClonedWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::RepoInitRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/repo/init"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::RepoInitRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIInitRepo);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIInitRepo) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPIInitRepo) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::RepoInitResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 400:
		SetResponseString(TEXT("User error"));
		break;
	}
}

bool OpenAPIDefaultApi::RepoInitResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ResumeWorkspaceSyncRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/workspace/{WorkspaceID}/sync/resume"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::ResumeWorkspaceSyncRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ResumeWorkspaceSyncResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	case 404:
		SetResponseString(TEXT("Workspace with the input parameters not found"));
		break;
	case 409:
		SetResponseString(TEXT("Workspace is already running"));
		break;
	}
}

bool OpenAPIDefaultApi::ResumeWorkspaceSyncResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::UpdateCoreCredentialsRequest::ComputePath() const
{
	FString InnerGeneratorOpenAPIPath(TEXT("/token/core"));
	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::UpdateCoreCredentialsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICoreApiCredentials);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPICoreApiCredentials) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Body parameter (OpenAPICoreApiCredentials) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogAgentAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::UpdateCoreCredentialsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::UpdateCoreCredentialsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::WorkspaceStructureDumpRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("RepoID"), FStringFormatArg(ToUrlString(RepoID)) },
	{ TEXT("WorkspaceID"), FStringFormatArg(ToUrlString(WorkspaceID)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repo/{RepoID}/workspace/{WorkspaceID}/debug/dump"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIDefaultApi::WorkspaceStructureDumpRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIDefaultApi::WorkspaceStructureDumpResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIDefaultApi::WorkspaceStructureDumpResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	// Content is a file, no available JSON conversion
	return false;
}

}
