// Copyright 2024 Diversion Company, Inc. All Rights Reserved.
/**
 * Diversion Core API
 * Definition of the Core API used to access low-level functionality of Diversion
 *
 * OpenAPI spec version: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIRepositoryWorkspaceManipulationApiOperations.h"

#include "CoreAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace CoreAPI
{

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceApplyClientUpdatesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/updates"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceApplyClientUpdatesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Header parameters
	HttpRequest->SetHeader(TEXT("X-Dv-Client-Id"), XDvClientId);
	if (XDvHasUploads.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-Dv-Has-Uploads"), LexToString(XDvHasUploads.GetValue()));
	}
	if (XDvHostName.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-Dv-Host-Name"), XDvHostName.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIClientUpdates);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIClientUpdates) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIClientUpdates) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceApplyClientUpdatesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 207:
		SetResponseString(TEXT("Mixed results"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceApplyClientUpdatesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCheckoutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/checkout"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCheckoutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIWorkspaceCheckout);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIWorkspaceCheckout) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIWorkspaceCheckout) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCheckoutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 409:
		SetResponseString(TEXT("Operation failed due to pending changes on the resource"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCheckoutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCherryPickRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/cherry-pick"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCherryPickRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPISrcHandlersv2WorkspaceCherryPickRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPISrcHandlersv2WorkspaceCherryPickRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPISrcHandlersv2WorkspaceCherryPickRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCherryPickResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("The commit&#39;s patch was applied to the workspace"));
		break;
	case 202:
		SetResponseString(TEXT("The cherry-pick is in progress. It has conflicts requiring active input from the user for conflict resolution. The response contains a merge ID, which can be used for querying /repos/{repo_id}/merges/{merge_id}"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCherryPickResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCreateWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCreateWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	HttpRequest->SetHeader(TEXT("X-Dv-Client-Id"), XDvClientId);

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPINewWorkspace);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPINewWorkspace) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPINewWorkspace) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCreateWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 201:
		SetResponseString(TEXT("Resource created"));
		break;
	case 409:
		SetResponseString(TEXT("Workspace with the same name already exists"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceCreateWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceForwardWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/forward"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceForwardWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceForwardWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 200:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 202:
		SetResponseString(TEXT("The merge is in progress. It has merge conflicts requiring active input from the user for conflict resolution. The response contains a merge ID, which can be used for querying /repos/{repo_id}/merges/{merge_id}"));
		break;
	case 412:
		SetResponseString(TEXT("Workspace is detached"));
		break;
	case 503:
		SetResponseString(TEXT("Service unavailable"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceForwardWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetClientShouldUploadLogsRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/should_upload_logs"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetClientShouldUploadLogsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	HttpRequest->SetHeader(TEXT("X-Dv-Client-Id"), XDvClientId);

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetClientShouldUploadLogsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Checks whether a workspace was marked to upload its client and agent logs"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetClientShouldUploadLogsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetOtherStatusesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/other_statuses"), PathParams);

	TArray<FString> QueryParams;
	if(PathPrefix.IsSet())
	{
		QueryParams.Add(FString(TEXT("path_prefix=")) + ToUrlString(PathPrefix.GetValue()));
	}
	if(PathPrefixes.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(PathPrefixes.GetValue(), TEXT("path_prefixes")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Skip.IsSet())
	{
		QueryParams.Add(FString(TEXT("skip=")) + ToUrlString(Skip.GetValue()));
	}
	if(Recurse.IsSet())
	{
		QueryParams.Add(FString(TEXT("recurse=")) + ToUrlString(Recurse.GetValue()));
	}
	InnerGeneratorOpenAPIPath += TCHAR('?');
	InnerGeneratorOpenAPIPath += FString::Join(QueryParams, TEXT("&"));

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetOtherStatusesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetOtherStatusesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("By path description of file statuses in other workspaces and branches"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetOtherStatusesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetPreferencesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/preferences"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetPreferencesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetPreferencesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Preferences of the workspace for the user"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetPreferencesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetStatusRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/status"), PathParams);

	TArray<FString> QueryParams;
	if(DetailItems.IsSet())
	{
		QueryParams.Add(FString(TEXT("detail_items=")) + ToUrlString(DetailItems.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Skip.IsSet())
	{
		QueryParams.Add(FString(TEXT("skip=")) + ToUrlString(Skip.GetValue()));
	}
	if(Recurse.IsSet())
	{
		QueryParams.Add(FString(TEXT("recurse=")) + ToUrlString(Recurse.GetValue()));
	}
	if(PathPrefix.IsSet())
	{
		QueryParams.Add(FString(TEXT("path_prefix=")) + ToUrlString(PathPrefix.GetValue()));
	}
	if(AllowTrim.IsSet())
	{
		QueryParams.Add(FString(TEXT("allow_trim=")) + ToUrlString(AllowTrim.GetValue()));
	}
	InnerGeneratorOpenAPIPath += TCHAR('?');
	InnerGeneratorOpenAPIPath += FString::Join(QueryParams, TEXT("&"));

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetStatusRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetStatusResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("The changes made to this workspace since the commit it&#39;s based upon."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetStatusResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetUploadingAgentsRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/uploading_agents"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetUploadingAgentsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetUploadingAgentsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("A list of host names (or client ID if not available) that have pending uploads"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetUploadingAgentsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Workspace details returned"));
		break;
	case 404:
		SetResponseString(TEXT("The specified resource was not found"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceUpdatesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/updates"), PathParams);

	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("from_ordinal_id=")) + ToUrlString(FromOrdinalId));
	InnerGeneratorOpenAPIPath += TCHAR('?');
	InnerGeneratorOpenAPIPath += FString::Join(QueryParams, TEXT("&"));

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceUpdatesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	HttpRequest->SetHeader(TEXT("X-Dv-Client-Id"), XDvClientId);
	if (XDvHasUploads.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-Dv-Has-Uploads"), LexToString(XDvHasUploads.GetValue()));
	}
	if (XDvHostName.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-Dv-Host-Name"), XDvHostName.GetValue());
	}

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceUpdatesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("The changes made to this workspace since the commit it&#39;s based upon."));
		break;
	case 404:
		SetResponseString(TEXT("The specified resource was not found"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceGetWorkspaceUpdatesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceListAllWorkspacesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceListAllWorkspacesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceListAllWorkspacesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceListAllWorkspacesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceRenameWorkspaceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/rename"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceRenameWorkspaceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIWorkspaceRename);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIWorkspaceRename) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIWorkspaceRename) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceRenameWorkspaceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 409:
		SetResponseString(TEXT("Workspace with the same name already exists"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceRenameWorkspaceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceResetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/reset"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceResetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPISrcHandlersv2WorkspaceResetRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPISrcHandlersv2WorkspaceResetRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPISrcHandlersv2WorkspaceResetRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceResetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("The updated status of the workspace"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceResetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetPreferencesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/preferences"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetPreferencesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIWorkspacePreferences);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIWorkspacePreferences) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Body parameter (OpenAPIWorkspacePreferences) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetPreferencesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 202:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 409:
		SetResponseString(TEXT("Cannot save preferences"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("An error occurred"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetPreferencesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetUploadingRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("repo_id"), FStringFormatArg(ToUrlString(RepoId)) },
	{ TEXT("workspace_id"), FStringFormatArg(ToUrlString(WorkspaceId)) } };

	FString InnerGeneratorOpenAPIPath = FString::Format(TEXT("/repos/{repo_id}/workspaces/{workspace_id}/set_uploading"), PathParams);

	return InnerGeneratorOpenAPIPath;
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetUploadingRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	HttpRequest->SetHeader(TEXT("X-Dv-Client-Id"), XDvClientId);
	if (XDvHasUploads.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-Dv-Has-Uploads"), LexToString(XDvHasUploads.GetValue()));
	}
	if (XDvHostName.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-Dv-Host-Name"), XDvHostName.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogCoreAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetUploadingResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Request completed successfully"));
		break;
	case 404:
		SetResponseString(TEXT("The specified resource was not found"));
		break;
	}
}

bool OpenAPIRepositoryWorkspaceManipulationApi::SrcHandlersv2WorkspaceSetUploadingResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

}
