// Copyright 2024 Diversion Company, Inc. All Rights Reserved.
/**
 * Diversion Core API
 * Definition of the Core API used to access low-level functionality of Diversion
 *
 * The version of the OpenAPI document: 0.2.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.10.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "JsonBody.h"

#include "Misc/FileHelper.h"
#include "Misc/Paths.h"

namespace Diversion
{
namespace CoreAPI
{
namespace Model
{

HttpFileInput::HttpFileInput(const TCHAR* InFilePath)
{
	SetFilePath(InFilePath);
}

HttpFileInput::HttpFileInput(const FString& InFilePath)
{
	SetFilePath(InFilePath);
}

void HttpFileInput::SetFilePath(const TCHAR* InFilePath)
{
	FilePath = InFilePath;
	if(ContentType.IsEmpty())
	{
		// ContentType = FPlatformHttp::GetMimeType(InFilePath);
	}
}

void HttpFileInput::SetFilePath(const FString& InFilePath)
{
	SetFilePath(*InFilePath);
}

void HttpFileInput::SetContentType(const TCHAR* InContentType)
{
	ContentType = InContentType;
}

FString HttpFileInput::GetFilename() const
{
	return FPaths::GetCleanFilename(FilePath);
}

//////////////////////////////////////////////////////////////////////////

bool ParseDateTime(const FString& DateTimeString, FDateTime& OutDateTime)
{
	// Iso8601 Format: 	DateTime: YYYY-mm-ddTHH:MM:SS(.sss)(Z|+hh:mm|+hhmm|-hh:mm|-hhmm)
	{
		// We cannot call directly FDateTime::ParseIso8601 because it does not allow for precision beyond the millisecond, but DateTimeString might have more digits
		int32 DotIndex;
		FString StringToParse = DateTimeString;
		if (DateTimeString.FindChar('.', DotIndex))
		{
			int32 TimeZoneIndex;
			if (DateTimeString.FindChar('Z', TimeZoneIndex) || DateTimeString.FindChar('+', TimeZoneIndex) || DateTimeString.FindChar('-', TimeZoneIndex))
			{
				// The string contains a time zone designator starting at TimeZoneIndex
				if (TimeZoneIndex > DotIndex + 4)
				{
					// Trim to millisecond
					StringToParse = DateTimeString.Left(DotIndex + 4) + DateTimeString.RightChop(TimeZoneIndex);
				}
			}
			else
			{
				// the string does not contain a time zone designator, trim it to the millisecond
				StringToParse = DateTimeString.Left(DotIndex + 4);
			}
		}

		if (FDateTime::ParseIso8601(*StringToParse, OutDateTime))
			return true;
	}

	if (FDateTime::ParseHttpDate(DateTimeString, OutDateTime))
		return true;

	return FDateTime::Parse(DateTimeString, OutDateTime);
}

}
}
}
