// Copyright 2024 Diversion Company, Inc. All Rights Reserved.
/**
 * Diversion Core API
 * Definition of the Core API used to access low-level functionality of Diversion
 *
 * The version of the OpenAPI document: 0.2.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.10.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "HttpContent.h"
#include "Misc/Base64.h"
#include "Misc/FileHelper.h"
#include "HAL/PlatformFilemanager.h"
#include "Misc/Paths.h"

namespace Diversion {
namespace CoreAPI {
namespace Model {

HttpContent::HttpContent()
{
}

HttpContent::~HttpContent()
{
}

FString HttpContent::GetContentDisposition() const
{
    return ContentDisposition;
}

void HttpContent::SetContentDisposition(const FString& Value)
{
    ContentDisposition = Value;
}

FString HttpContent::GetName() const
{
    return Name;
}

void HttpContent::SetName(const FString& Value)
{
    Name = Value;
}

FString HttpContent::GetFileName() const
{
    return FileName;
}

void HttpContent::SetFileName(const FString& Value)
{
    FileName = Value;
}

FString HttpContent::GetContentType() const
{
    return ContentType;
}

void HttpContent::SetContentType(const FString& Value)
{
    ContentType = Value;
}

TSharedPtr<TArray<uint8>> HttpContent::GetData() const
{
    return Data;
}

void HttpContent::SetData(TSharedPtr<TArray<uint8>> Value)
{
    Data = Value;
}

void HttpContent::WriteTo(FArchive& Archive)
{
    if (Data.IsValid())
    {
        Archive.Serialize(Data->GetData(), Data->Num());
    }
}

FString HttpContent::WriteToString() const
{
    FString Result;
    if (Data.IsValid())
    {
        Result.Reserve(Data->Num());
        for (uint8 Byte : *Data)
        {
            Result.AppendChar(static_cast<TCHAR>(Byte));
        }
    }
    return Result;
}

void HttpContent::WriteJson(JsonWriter& Writer) const
{
	if (Data.IsValid())
    {
        FString EncodedData = FBase64::Encode(*Data);
        Writer->WriteObjectStart();
        Writer->WriteValue(TEXT("Content-Disposition"), ContentDisposition);
        Writer->WriteValue(TEXT("Name"), Name);
        Writer->WriteValue(TEXT("FileName"), FileName);
        Writer->WriteValue(TEXT("ContentType"), ContentType);
        Writer->WriteValue(TEXT("Data"), EncodedData);
        Writer->WriteObjectEnd();
    }
}

void HttpContent::FromString(const FString& InString)
{
    TArray<uint8> ByteArray;
    ByteArray.Reserve(InString.Len());
    for (TCHAR Char : InString)
    {
        ByteArray.Add(static_cast<uint8>(Char));
    }
    Data = MakeShared<TArray<uint8>>(MoveTemp(ByteArray));
}

bool HttpContent::WriteToFile(const FString& FilePath) const
{
    if (!Data.IsValid())
    {
        return false;
    }

    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    // Ensure the directory exists
    FString Directory = FPaths::GetPath(FilePath);
    if (!PlatformFile.DirectoryExists(*Directory))
    {
        PlatformFile.CreateDirectoryTree(*Directory);
    }

    return FFileHelper::SaveArrayToFile(*Data, *FilePath);
}

bool HttpContent::ReadFromFile(const FString& FilePath)
{
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.FileExists(*FilePath))
    {
        return false;
    }

    TArray<uint8> ByteArray;
    if (FFileHelper::LoadFileToArray(ByteArray, *FilePath))
    {
        Data = MakeShared<TArray<uint8>>(MoveTemp(ByteArray));
        return true;
    }

    return false;
}

}
}
}
